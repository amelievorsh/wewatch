<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FACE_MESH_TRACKER - Firebase</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.10.0/p5.js"></script>
  <script src="https://unpkg.com/ml5@1/dist/ml5.min.js"></script>
  
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  
  <style>
    :root { --tracker-color: #00ff64; }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: var(--tracker-color);
      overflow: hidden;
    }
    #overlay {
      position: fixed; top: 20px; left: 20px; z-index: 1000;
      background: rgba(0, 0, 0, 0.9);
      padding: 20px; border: 2px solid var(--tracker-color);
      max-width: 400px; font-size: 12px;
    }
    #status { color: var(--tracker-color); font-weight: bold; margin-bottom: 10px; font-size: 16px; }
    .data-point { font-size: 12px; margin: 5px 0; color: var(--tracker-color); }
    #meshInfo { margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--tracker-color); }
    #sendStatus { margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--tracker-color); font-size: 11px; color: #888; }
    canvas { display: block; }
    .active { color: #0f0; font-weight: bold; }
    .firebase-status {
      padding: 10px; margin-bottom: 15px;
      border: 1px solid var(--tracker-color);
      background: rgba(0, 255, 100, 0.1);
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div class="firebase-status">
      <div style="font-size: 11px;">FIREBASE STATUS:</div>
      <div id="firebaseStatus" style="font-size: 12px; margin-top: 5px;">Connecting...</div>
    </div>

    <div id="status">‚óè FACE_MESH_TRACKER - ACTIVE</div>
    <div id="data">
      <div class="data-point">FACES DETECTED: 0</div>
      <div class="data-point">EXPRESSION: None Detected</div>
      <div class="data-point">CONFIDENCE: 0.0%</div>
    </div>
    <div id="meshInfo">
      <div class="data-point">TRIANGLES: 0</div>
      <div class="data-point">ANIMATION TIME: 0.00s</div>
      <div class="data-point">AMPLITUDE: 9px</div>
      <div class="data-point">FREQUENCY: 1.2</div>
    </div>
    <div id="sendStatus">Initializing Firebase...</div>
  </div>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyC9T0hhAF8KDWRIQZsiBdneslvx3mlgYU4",
      authDomain: "buffer02-40ffe.firebaseapp.com",
      databaseURL: "https://buffer02-40ffe-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "buffer02-40ffe",
      storageBucket: "buffer02-40ffe.firebasestorage.app",
      messagingSenderId: "213473674962",
      appId: "1:213473674962:web:60bbde3c9303b3c06a4f0b",
      measurementId: "G-ZTJW8P42SP"
    };

    const CONFIG = { 
      trackerName: 'FACE_MESH_TRACKER', 
      sendInterval: 1500,
      amplitude: 35, 
      frequency: 1.2,
      videoScale: 1.5
    };
    
    const EXPRESSION_CONFIG = {
      mouthOpenThreshold: 12,
      mouthClosedThreshold: 8,
      tiltThreshold: 1.5,
      smileThreshold: 3,
      browRaiseThreshold: 5,
      minSendConfidence: 0.15
    };

    let sendCount = 0, database, firebaseConnected = false;
    let lastSendTime = 0;
    let isSending = false;
    
    try {
      firebase.initializeApp(firebaseConfig);
      database = firebase.database();
      const connectedRef = database.ref('.info/connected');
      connectedRef.on('value', (snap) => {
        if (snap.val() === true) {
          firebaseConnected = true;
          document.getElementById('firebaseStatus').innerHTML = '‚úì Connected to Firebase';
          document.getElementById('sendStatus').innerHTML = '‚úì Ready to send data';
        } else {
          firebaseConnected = false;
          document.getElementById('firebaseStatus').innerHTML = '‚úó Disconnected';
        }
      });
    } catch (error) {
      console.error('Firebase initialization error:', error);
      document.getElementById('firebaseStatus').innerHTML = '‚úó Configuration Error';
      document.getElementById('sendStatus').innerHTML = '‚úñ Firebase error';
    }

    let video, faceMesh, faces = [], triangles, t = 0;

    function detectExpressions(face) {
      if (!face || !face.keypoints) return [];
      const k = face.keypoints;
      
      const upperLip = k[13];
      const lowerLip = k[14];
      const leftEye = k[33];
      const rightEye = k[263];
      const leftMouthCorner = k[61];
      const rightMouthCorner = k[291];
      const leftBrowMid = k[105];
      const rightBrowMid = k[334];
      const leftEyeCenter = k[159];
      const rightEyeCenter = k[386];
      
      if (!upperLip || !lowerLip || !leftEye || !rightEye || !leftMouthCorner || !rightMouthCorner || !leftBrowMid || !rightBrowMid || !leftEyeCenter || !rightEyeCenter) return [];

      const expressions = [];
      
      const mouthDist = dist(upperLip.x, upperLip.y, lowerLip.x, lowerLip.y);
      
      if (mouthDist > EXPRESSION_CONFIG.mouthOpenThreshold) {
        const confidence = Math.min(1.0, (mouthDist - EXPRESSION_CONFIG.mouthOpenThreshold) / 30);
        expressions.push({ expression: "mouth_open", confidence: confidence });
      }
      
      if (mouthDist < EXPRESSION_CONFIG.mouthClosedThreshold) {
        const confidence = Math.min(1.0, (EXPRESSION_CONFIG.mouthClosedThreshold - mouthDist) / 8);
        expressions.push({ expression: "mouth_closed", confidence: confidence });
      }

      const tiltDiff = leftEye.y - rightEye.y;
      if (Math.abs(tiltDiff) > EXPRESSION_CONFIG.tiltThreshold) {
        const confidence = Math.min(1.0, Math.abs(tiltDiff) / 15);
        if (tiltDiff > 0) {
          expressions.push({ expression: "head_tilt_right", confidence: confidence });
        } else {
          expressions.push({ expression: "head_tilt_left", confidence: confidence });
        }
      }

      const mouthCenterY = (leftMouthCorner.y + rightMouthCorner.y) / 2;
      const smileDiff = mouthCenterY - lowerLip.y;
      if (smileDiff > EXPRESSION_CONFIG.smileThreshold) {
        const confidence = Math.min(1.0, smileDiff / 15);
        expressions.push({ expression: "smiling", confidence: confidence });
      }

      const browYAvg = (leftBrowMid.y + rightBrowMid.y) / 2;
      const eyeYAvg = (leftEyeCenter.y + rightEyeCenter.y) / 2;
      const browDiff = eyeYAvg - browYAvg;
      if (browDiff > EXPRESSION_CONFIG.browRaiseThreshold) {
        const confidence = Math.min(1.0, browDiff / 20);
        expressions.push({ expression: "eyebrows_raised", confidence: confidence });
      }

      if (expressions.length === 0) {
        expressions.push({ expression: "neutral", confidence: 0.5 });
      }

      return expressions.sort((a, b) => b.confidence - a.confidence);
    }

    async function sendExpressionData(expression, confidence) {
      if (!firebaseConnected || isSending) {
        return;
      }
      
      const now = millis();
      if (now - lastSendTime < CONFIG.sendInterval) {
        return;
      }
      
      isSending = true;
      
      const data = {
        tracker: CONFIG.trackerName,
        timestamp: Date.now(),
        expression: expression,
        confidence: confidence
      };

      try {
        await database.ref('data/face_mesh_data').set(data);
        sendCount++;
        lastSendTime = now;
        document.getElementById('sendStatus').innerHTML =
          `‚úì Sent ${sendCount} updates<br>${expression.toUpperCase().replace(/_/g, ' ')} (${(confidence * 100).toFixed(1)}%)`;
      } catch (error) {
        console.error('Firebase write error:', error);
        document.getElementById('sendStatus').innerHTML = `‚úñ Error: ${error.message}`;
      } finally {
        isSending = false;
      }
    }

    function updateUI(detectedExpressions) {
      const dataDiv = document.getElementById('data');
      const meshDiv = document.getElementById('meshInfo');
      const primary = detectedExpressions[0] || null;
      const expressionText = primary ? primary.expression.replace(/_/g, ' ') : 'None Detected';
      const confidenceText = primary ? (primary.confidence * 100).toFixed(1) + '%' : '0.0%';
      const activeClass = primary && primary.confidence >= EXPRESSION_CONFIG.minSendConfidence ? 'active' : '';

      dataDiv.innerHTML = `
        <div class="data-point ${activeClass}">FACES DETECTED: ${faces.length}</div>
        <div class="data-point">EXPRESSION: ${expressionText.toUpperCase()}</div>
        <div class="data-point">CONFIDENCE: ${confidenceText}</div>
      `;
      meshDiv.innerHTML = `
        <div class="data-point">TRIANGLES: ${triangles ? triangles.length : 0}</div>
        <div class="data-point">ANIMATION TIME: ${t.toFixed(2)}s</div>
        <div class="data-point">AMPLITUDE: ${CONFIG.amplitude}px</div>
        <div class="data-point">FREQUENCY: ${CONFIG.frequency}</div>
      `;
    }

    function gotFaces(results) { faces = results; }
    function preload() { faceMesh = ml5.faceMesh({ maxFaces: 1, flipped: true }); }
    function setup() {
      createCanvas(windowWidth, windowHeight);
      video = createCapture(VIDEO, { flipped: true });
      video.size(windowWidth * CONFIG.videoScale, windowHeight * CONFIG.videoScale);
      video.hide();
      faceMesh.detectStart(video, gotFaces);
      triangles = faceMesh.getTriangles();
      console.log('üé• FACE_MESH_TRACKER initialized with Firebase');
    }

    function draw() {
      background(0);
      push();
      translate(width / 2, height / 2);
      scale(CONFIG.videoScale);
      translate(-width / 2, -height / 2);
      
      let currentExpressions = [];

      if (faces.length > 0) {
        const face = faces[0];
        currentExpressions = detectExpressions(face);

        const filtered = currentExpressions.filter(e => e.confidence >= EXPRESSION_CONFIG.minSendConfidence);
        
        if (filtered.length > 0) {
          const primary = filtered[0];
          sendExpressionData(primary.expression, primary.confidence);
        }

        beginShape(TRIANGLES);
        noFill();
        stroke(0, 255, 100, 180);
        strokeWeight(1);
        for (let i = 0; i < triangles.length; i++) {
          const tri = triangles[i];
          const [a, b, c] = tri;
          const A = face.keypoints[a], B = face.keypoints[b], C = face.keypoints[c];
          const ax = A.x + sin(t + i * CONFIG.frequency) * CONFIG.amplitude / PI;
          vertex(ax, A.y); vertex(B.x, B.y); vertex(C.x, C.y);
        }
        endShape();
        t += 0.03;
      }
      
      pop();
      updateUI(currentExpressions);
    }
  </script>
</body>
</html>